# Что такое "стандарт языка" Си?
- [ ] Это набор библиотек, поставляемых вместе с компилятором
- [ ] Это специфическая реализация языка Си для определенной операционной системы
- [x] Это официальная спецификация, определяющая синтаксис и семантику языка Си
- [ ] Это набор правил форматирования кода, рекомендованных для языка Си

## :desc
Стандарт языка Си — это официальная спецификация, определяющая синтаксис и семантику языка Си. Он включает правила и требования, которым должны соответствовать компиляторы, чтобы обеспечить совместимость и переносимость кода между различными платформами и реализациями.

---

# Какой из следующих стандартов языка Си является последним на момент 2024 года?
- [ ] C99
- [ ] C11
- [ ] C14
- [x] C18

## :desc
На момент 2024 года последним стандартом языка Си является C18, который представляет собой небольшое обновление стандарта C11, исправляющее некоторые ошибки и уточняющее определенные аспекты языка.

---

# Какой из следующих компиляторов относится к языку Си?
- [x] GCC
- [ ] JDK
- [ ] PyInstaller
- [ ] .NET

## :desc
GCC (GNU Compiler Collection) — это набор компиляторов, который поддерживает несколько языков программирования, включая Си. Он является основным компилятором на Unix-подобных операционных системах, таких как Linux и является свободным программным обеспечением.

JDK относится к Java, PyInstaller — инструмент для компиляции Python (по-умолчанию, Python - интерпретируемый язык), а .NET — к C# и другим языкам на платформе .NET.

---

# Каковы основные этапы компиляции исходного кода на языке Си?
- [ ] Трансляция (компиляция), линковка
- [x] Препроцессинг, трансляция (компиляция), линковка
- [ ] Линковка, трансляция (компиляция), постпроцессинг
- [ ] Препроцессинг, трансляция (компиляция)

## :desc
Первый этап компиляции исходного кода на языке Си — это *препроцессинг*. На этом этапе препроцессор обрабатывает директивы препроцессора, такие как `#include`, `#define`, и выполняет подстановки теста в соответствии с заданными директивами и их условиями.

Второй этап — это *трансляция* (компиляция + ассемблирование). На этапе трансляции файлы исходного кода преобразуется в файлы с промежуточным ассемблерным кодом. Этот код затем передается на следующий этап — ассемблирование. На этапе ассемблирования ассемблерный код преобразуется в объектный код. Объектный же код уже представляет собой машинные инструкции, которые могут быть выполнены процессором.

Последний, третий этап компиляции — это *линковка* или компановка. На этом этапе объектные файлы и библиотеки связываются вместе для создания окончательного исполняемого файла или библиотеки.

---

# Что происходит на этапе препроцессинга?
- [ ] Исходный код преобразуется в объектный код
- [ ] Исходный код преобразуется в машинный код
- [ ] Директивы препроцессора связываются вместе
- [x] Обрабатываются директивы препроцессора

## :desc
Первый этап компиляции исходного кода на языке Си — это *препроцессинг*. На этом этапе препроцессор обрабатывает директивы препроцессора, такие как `#include`, `#define`, и выполняет подстановки теста в соответствии с заданными директивами и их условиями.

---

# Что делает директива `#include` на этапе препроцессинга?
- [x] Включает содержимое других файлов в текущий файл
- [ ] Определяет макросы
- [ ] Подключает стандартные библиотеки
- [ ] Экспортирует содержимое текущего файла в указанный

## :desc
Директивы `#include` на этапе препроцессинга включают содержимое других файлов в текущий файл. Это позволяет использовать заголовочные файлы для объявления функций, переменных и структур данных.

---

# Что делает директива `#define` на этапе препроцессинга?
- [ ] Используется только для "define-guard'ов"
- [x] Определяет макрос или символическую константу
- [ ] Является устаревшей конструкцией объявления функций
- [ ] Объявляет глобальные переменные

## :desc
Директива `#define` на этапе препроцессинга определяет макрос или символическую константу, которая затем подставляется в код в местах использования.

---

# Какая директива используется для условной компиляции кода?
- [ ] `#pragma`
- [ ] `#define`
- [x] `#ifdef`
- [ ] `#error`

## :desc
Директива `#ifdef` используется для условной компиляции кода, идёт в паре с `#endif`. Она позволяет включать выделенные участки кода только в том случае, если определен соответствующий макрос. Например, `#ifdef FOO <...code...> #endif` включит блок кода `<...code...>` только в том случае, если ранее был определён макрос `FOO`.

Инвертированный вариант директивы - `#ifndef`.

---

# Что происходит с комментариями на этапе препроцессинга?
- [ ] Они помечаются как часть кода, которую не нужно компилировать
- [ ] Они остаются без изменений
- [x] Они удаляются из исходного кода

## :desc
На этапе препроцессинга комментарии удаляются из исходного кода, чтобы они не влияли на дальнейшие этапы компиляции.

---

# Какую роль играет директива `#undef` на этапе препроцессинга?
- [ ] Определяет новый макрос
- [ ] Исправляет значение определённого макроса
- [x] Отменяет определение макроса
- [ ] Пропускает часть кода во время компиляции

## :desc
Директива `#undef` на этапе препроцессинга отменяет определение макроса, заданного ранее с помощью директивы `#define`.

---

# Что происходит с директивами препроцессора на последующих этапах компиляции?
- [ ] Они преобразуются в ассемблерный код
- [ ] Они остаются в исходном виде
- [x] Они удаляются из исходного кода после обработки
- [ ] Они преобразуются в комментарии

## :desc
После обработки на этапе препроцессинга директивы препроцессора удаляются из исходного кода.

---

# Что такое include-guard?
- [ ] Макрос, который автоматически генерирует уникальные имена для функций
- [ ] Препроцессорная директива, позволяющая включать файлы только один раз
- [x] Препроцессорный механизм для предотвращения многократного включения одного и того же заголовочного файла
- [ ] Один из способов подключить файл с помощью `#include`

## :desc
`Include-guard` (ещё называют "define-guard") — это конструкция для препроцессора по предотвращению многократного включения одного и того же заголовочного файла. Это делается с помощью директив `#ifndef`, `#define` и `#endif`. В противном случае, многократное включение одного и того же заголовочного файла приведёт к ошибки компиляции из-за повторого определения функций или структур данных.

Например, `include-guard` чтобы избежать многократного подключения заголовочного файла `file.h`:

```c
#ifndef FILE_H  // Если макрос FILE_H не был определён, то этот блок кода будет включён
#define FILE_H  // Определяем макрос FILE_H
// содержимое файла
#endif          // Окончания блока #ifndef
```

---

# Какую роль играет директива `#pragma` на этапе препроцессинга?
- [x] Задает специальные инструкции для компилятора
- [ ] Заменяет устаревший синтаксис "include-guard'ов"
- [ ] Включает содержимое указанного файла
- [ ] Пропускает часть кода во время компиляции

## :desc
Директива `#pragma` задает специальные инструкции для компилятора. Она используется для управления компиляцией в специфичных ситуациях. Например, она может использоваться вместо "include-guard'ов" как `#pragma once`, чтобы исключить зацикливание подключения файла через `#include`. Это не единственное применение этой директивы, но самое частое.

---

# Что происходит на этапе трансляции (компиляции)?
- [ ] Обработка директив препроцессора, таких как `#include` и `#define`
- [x] Преобразование файлов исходного кода в файлы объектного кода
- [ ] Включение файлов исходного кода подключенных библиотек в файл с функцией `main`
- [ ] Создание исполняемого файла

## :desc
На этапе трансляции (компиляция + ассемблирование) файлы исходного кода преобразуется в файлы с промежуточным ассемблерным кодом. Этот код затем передается на следующий этап — ассемблирование. На этапе ассемблирования ассемблерный код преобразуется в объектный код. Объектный же код уже представляет собой машинные инструкции, которые могут быть выполнены процессором.

На этапе трансляции, компилятор также может выполнять задачи по оптимизации кода.

---

# Что проверяется компилятором на этапе трансляции?
- [x] Синтаксические и семантические ошибки
- [ ] Логические ошибки в коде
- [ ] Соответствие на code-style
- [ ] Права доступа к файлам

## :desc
Компилятор на этапе трансляции проверяет исходный код на наличие синтаксических и семантических ошибок. Он гарантирует, что код соответствует синтаксису и правилам языка Си.

---

# Что происходит на этапе линковки (компановки)?
- [ ] Преобразование исходного кода в объектный код
- [ ] Связывание директив препроцессора между разными файлами
- [ ] Связывание функции `main` с функциями стандартной библиотеки
- [x] Связывание объектных файлов и библиотек для создания исполняемого файла

## :desc
На этапе линковки (или компоновки) происходит связывание объектных файлов и библиотек для создания окончательного исполняемого файла. Это включает разрешение ссылок на внешние функции и переменные.

---

# Какую роль играет линкер в процессе компиляции?
- [ ] Преобразует исходный код в объектный код
- [ ] Связывает директивы препроцессора между разными файлами
- [x] Связывает объектные файлы и библиотеки для создания исполняемого файла
- [ ] Связывает функцию `main` с функциями стандартной библиотеки

## :desc
Линкер связывает объектные файлы и библиотеки для создания окончательного исполняемого файла. Это включает разрешение ссылок на внешние функции и переменные.

---

# Какую ошибку может выдать линкер, если функция объявлена, но не определена?
- [ ] Ошибку синтаксиса
- [ ] Ошибку препроцессора
- [ ] Ошибку оптимизации
- [x] Ошибку неразрешенной ссылки

## :desc
Линкер может выдать ошибку неразрешенной ссылки (`LINK`), если функция объявлена в коде, но не определена ни в одном из объектных файлов или библиотек.

---

# Какие файлы линкер использует в качестве входных на этапе линковки?
- [ ] Исходные файлы на языке Си
- [ ] Промежуточные файлы с расширением `.i`
- [ ] Ассемблерные файлы с расширением `.s`
- [x] Объектные файлы с расширением `.o` или `.obj` и библиотеки

## :desc
На этапе линковки линкер использует объектные файлы с расширением `.o` или `.obj` и библиотеки в качестве входных файлов для создания исполняемого файла.